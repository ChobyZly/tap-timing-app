<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Chord Tapper v2.7 (Kompletný)</title>
<style>
/* --- Všetky CSS štýly ostávajú bez zmeny --- */
:root { color-scheme: dark; }
body { font-family: Arial, sans-serif; margin: 1em; background:#0f1115; color:#e6e6e6; }
label, select, button, input { font-size: 14px; }
#videoPlayerContainer { resize: vertical; overflow: auto; height: 240px; min-height: 150px; max-height: 80vh; margin-bottom: 1em; background: #000; border-radius: 8px; display: flex; align-items: center; justify-content: center; }
#videoPlayer { width: 100%; height: 100%; object-fit: contain; border-radius: 8px; }
.hidden { display: none; }
.controls-container { border: 1px solid #2a2d34; border-radius: 8px; padding: 0.75em; margin-bottom: 1em; display: flex; flex-direction: column; gap: 0.75em; }
.full-width-btn { width: 100%; padding: 0.8em; font-size: 1.1em; border: 1px solid #30333a; background:#181b22; color:#e6e6e6; border-radius:8px; cursor: pointer; }
#tappingControlsContainer { display: grid; grid-template-columns: 1fr 1fr; gap: 0.75em; margin-bottom: 1em; }
.tap-btn { padding: 1.5em; font-size: 1.5em; border-radius: 10px; border: 1px solid #30333a; background:#181b22; color:#e6e6e6; cursor: pointer; }
.tap-btn:disabled { opacity: 0.5; cursor: not-allowed; }
#tapSectionBtn { background: #3b82f6; border-color: #3b82f6; }
#sectionMarkerContainer { border: 1px solid #2a2d34; border-radius: 8px; padding: 0.75em; margin-bottom: 1em; display: flex; gap: 0.5em; align-items: center; }
#sectionNameInput { flex-grow: 1; padding: 0.7em; border-radius: 8px; border: 1px solid #30333a; background: #141821; color: #e6e6e6; font-size: 1em; }
#timer { font-size: 2em; margin: 0.25em 0 0.75em; font-variant-numeric: tabular-nums; }
table { width: 100%; border-collapse: collapse; margin-top: 0.5em; user-select: none; }
th, td { border: 1px solid #2a2d34; padding: 0.5em; position: relative; }
thead th { background:#141821; }
.timeCell.clickable-time { cursor: pointer; text-decoration: underline; text-decoration-color: #30333a; }
.timeCell.clickable-time:hover { color: #3b82f6; text-decoration-color: #3b82f6; }
.chordCell, .sectionCell { cursor: default; }
.chordCell[contenteditable="true"], .sectionCell[contenteditable="true"] { outline: 2px solid #3b82f6; cursor: text; }
tr.selected-row > td { background-color: #1e293b !important; }
.active-cell { box-shadow: inset 0 0 0 2px #3b82f6; }
#chordPopover { display: none; position: absolute; z-index: 1010; background: #141821; border: 1px solid #30333a; border-radius: 8px; padding: 0.5em; box-shadow: 0 4px 12px rgba(0,0,0,0.5); display: grid; grid-template-columns: repeat(4, 1fr); gap: 0.5em; width: 280px; }
#chordPopover.hidden { display: none; }
#chordPopover button { font-size: 1em; padding: 0.6em; }
.action-buttons { margin-top: 1em; display: flex; gap: 0.75em; }
.action-buttons button { padding: 0.6em 1em; font-size: 1em; border: 1px solid #30333a; background:#181b22; color:#e6e6e6; border-radius:10px; }
.action-buttons button:disabled { opacity: 0.5; cursor: not-allowed; }
.modal-overlay { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.7); justify-content: center; align-items: center; }
.modal-content { background-color: #181b22; padding: 1.5em; border: 1px solid #30333a; border-radius: 10px; width: 90%; max-width: 400px; text-align: center; }
.modal-content h3 { margin-top: 0; }
.selected-key-preview { font-size: 1.2em; margin-bottom: 1em; padding: 0.5em; background: #0f1115; border-radius: 6px; }
.quality-selector { display: flex; gap: 0.75em; margin-bottom: 1em; }
.quality-selector button { flex: 1; padding: 0.8em; font-size: 1em; border-radius: 8px; cursor: pointer; border: 1px solid #30333a; background: #2a2d34; color: #a9b0bd; }
.note-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 0.75em; margin-bottom: 1.5em; }
.note-grid button { padding: 0.8em 0; font-size: 1em; border-radius: 8px; cursor: pointer; border: 1px solid #30333a; background: #2a2d34; color: #a9b0bd;}
.quality-selector button.active, .note-grid button.active { background-color: #3b82f6; color: #e6e6e6; border-color: #3b82f6; font-weight: bold; }
.modal-actions { display: flex; gap: 1em; }
.modal-actions button { flex: 1; padding: 0.8em; font-size: 1em; border-radius: 8px; cursor: pointer; }
#confirmKeyBtn { border: none; background: #3b82f6; color: #e6e6e6; }
#cancelKeyBtn { border: 1px solid #30333a; background: #181b22; color: #a9b0bd; }
</style>
</head>
<body>

<div class="controls-container">
  <button id="insertFileBtn" class="full-width-btn">Insert File</button>
  <button id="selectKeyBtn" class="full-width-btn">Key: C</button>
</div>
<div id="videoPlayerContainer">
    <video id="videoPlayer" controls playsinline webkit-playsinline></video>
</div>
<div id="timer">00:00.000</div>
<div id="sectionMarkerContainer">
    <input type="text" id="sectionNameInput" placeholder="Názov sekcie (Intro, Verse...)">
</div>
<div id="tappingControlsContainer">
    <button id="tapChordBtn" class="tap-btn">Tap</button>
    <button id="tapSectionBtn" class="tap-btn">Tap Section</button>
</div>
<table id="logTable">
  <thead>
    <tr><th>#</th><th>Timestamp</th><th>Value</th><th>Section</th></tr>
  </thead>
  <tbody id="logTableBody"></tbody>
</table>
<div class="action-buttons">
    <button id="copyBtn" disabled>Copy (Ctrl+C)</button>
    <button id="pasteBtn" disabled>Paste (Ctrl+V)</button>
    <button id="exportBtn" disabled>Export CSV</button>
</div>
<div id="chordPopover" class="hidden"></div>
<div id="keyModal" class="modal-overlay">
  <div class="modal-content">
    <h3>Zvoľte tóninu</h3>
    <div id="selectedKeyDisplay" class="selected-key-preview"></div>
    <div class="quality-selector">
        <button data-quality="M">DUR</button>
        <button data-quality="m">mol</button>
    </div>
    <div class="note-grid">
        <button data-note="C" data-display="C">C</button><button data-note="C#" data-display="C#">C# / Db</button><button data-note="D" data-display="D">D</button><button data-note="D#" data-display="Eb">D# / Eb</button><button data-note="E" data-display="E">E</button><button data-note="F" data-display="F">F</button><button data-note="F#" data-display="F#">F# / Gb</button><button data-note="G" data-display="G">G</button><button data-note="G#" data-display="Ab">G# / Ab</button><button data-note="A" data-display="A">A</button><button data-note="A#" data-display="Bb">A# / Bb</button><button data-note="B" data-display="B">B</button>
    </div>
    <div class="modal-actions">
        <button id="cancelKeyBtn">Zrušiť</button>
        <button id="confirmKeyBtn">Potvrdiť</button>
    </div>
  </div>
</div>
<input id="fileInput" type="file" accept="video/*,audio/*" class="hidden" />

<script>
// --- Elements ---
const insertFileBtn = document.getElementById('insertFileBtn');
const selectKeyBtn = document.getElementById('selectKeyBtn');
const fileInput = document.getElementById('fileInput');
const videoPlayer = document.getElementById('videoPlayer');
const timerEl = document.getElementById('timer');
const sectionNameInput = document.getElementById('sectionNameInput');
const tapChordBtn = document.getElementById('tapChordBtn');
const tapSectionBtn = document.getElementById('tapSectionBtn');
const logTableBody = document.getElementById('logTableBody');
const exportBtn = document.getElementById('exportBtn');
const copyBtn = document.getElementById('copyBtn');
const pasteBtn = document.getElementById('pasteBtn');
const chordPopover = document.getElementById('chordPopover');
const keyModal = document.getElementById('keyModal');
const selectedKeyDisplay = document.getElementById('selectedKeyDisplay');
const qualitySelector = document.querySelector('.quality-selector');
const noteGrid = document.querySelector('.note-grid');
const confirmKeyBtn = document.getElementById('confirmKeyBtn');
const cancelKeyBtn = document.getElementById('cancelKeyBtn');

// --- State ---
let taps = [];
let timerInterval;
let playbackStarted = false;
let currentKey = { note: 'C', display: 'C', quality: 'M' };
let tempKey = {};
let editingRowIndex = null;
let selectedRows = new Set();
let lastSelectedRow = null;
let clipboard = [];
let activeCell = { row: null, col: null };
let selectionAnchor = null;
let originalCellValue = null;

// --- Music Theory Engine ---
const chromaticScale = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
const scalePatterns = { M: [0, 2, 4, 5, 7, 9, 11], m: [0, 2, 3, 5, 7, 8, 10] };
const chordPatterns = { M: ['', 'm', 'm', '', '', 'm', 'dim'], m: ['m', 'dim', '', 'm', 'm', '', ''] };
function generateDiatonicChords(key) {
    if (!key || !key.note || !key.quality) return [];
    const rootIndex = chromaticScale.indexOf(key.note);
    if (rootIndex === -1) return [];
    const pattern = scalePatterns[key.quality]; const chords = [];
    for (let i = 0; i < 7; i++) {
        const noteIndex = (rootIndex + pattern[i]) % 12; let noteName = chromaticScale[noteIndex];
        const chordQuality = chordPatterns[key.quality][i];
        const finalChordName = chordQuality === 'dim' ? `${noteName}5b` : `${noteName}${chordQuality}`;
        chords.push(finalChordName);
    }
    return chords;
}

// --- Fáza 1: Tapovanie ---
function formatTime(seconds) { const min = Math.floor(seconds / 60); const sec = Math.floor(seconds % 60); const ms = Math.floor((seconds - Math.floor(seconds)) * 1000); return `${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}.${ms.toString().padStart(3, '0')}`; }
function updateTimer() { if (videoPlayer.src) timerEl.textContent = formatTime(videoPlayer.currentTime); }
function addTap(options = { isSection: false }) {
    if (!videoPlayer.src) return; let currentTime;
    if (!playbackStarted) { playbackStarted = true; videoPlayer.currentTime = 0; videoPlayer.play(); currentTime = 0; } 
    else { if (videoPlayer.paused) return; currentTime = videoPlayer.currentTime; }
    const overwriteIndex = taps.findIndex(tap => tap.timeSec >= currentTime);
    if (overwriteIndex !== -1) taps = taps.slice(0, overwriteIndex);
    const newTap = { timeSec: currentTime, value: "Tap" };
    if (options.isSection) {
        const sectionName = sectionNameInput.value.trim();
        newTap.section = sectionName ? sectionName : "[Sekcia]";
        if (sectionName) sectionNameInput.value = '';
    }
    taps.push(newTap);
    renderTable();
    exportBtn.disabled = taps.length === 0;
}

// --- Fáza 2: Anotácia a Editácia ---
function hidePopover() { chordPopover.classList.add('hidden'); editingRowIndex = null; }
function showPopover(cell) {
    editingRowIndex = parseInt(cell.dataset.row);
    chordPopover.innerHTML = '';
    const chords = generateDiatonicChords(currentKey); chords.push('X');
    chords.forEach(chordName => {
        const btn = document.createElement('button'); btn.textContent = chordName; btn.dataset.value = chordName;
        chordPopover.appendChild(btn);
    });
    const rect = cell.getBoundingClientRect();
    chordPopover.style.top = `${window.scrollY + rect.bottom}px`;
    chordPopover.style.left = `${window.scrollX + rect.left}px`;
    chordPopover.classList.remove('hidden');
}
function copySelection() {
    if (selectedRows.size === 0) return; clipboard = [];
    const sortedIndices = [...selectedRows].sort((a, b) => a - b);
    sortedIndices.forEach(index => clipboard.push(taps[index].value));
    pasteBtn.disabled = false;
}
function pasteSelection() {
    if (clipboard.length === 0 || activeCell.row === null) return;
    const startPasteIndex = activeCell.row;
    clipboard.forEach((chordValue, i) => {
        let destIndex;
        if (isPhase2()) {
            destIndex = startPasteIndex + i;
        } else {
            destIndex = startPasteIndex - i;
        }
        if (taps[destIndex]) {
            taps[destIndex].value = chordValue;
        }
    });
    renderTable();
}

// --- Vykresľovanie a UI ---
function isPhase2() { return videoPlayer.paused && playbackStarted; }
function renderTable() {
    logTableBody.innerHTML = '';
    const renderRow = (tap, dataIndex) => {
        const tr = document.createElement('tr');
        if (selectedRows.has(dataIndex)) tr.classList.add('selected-row');
        tr.dataset.dataIndex = dataIndex;
        tr.innerHTML += `<td>${dataIndex + 1}</td>`;
        const tdTime = document.createElement('td');
        tdTime.className = 'timeCell clickable-time';
        tdTime.textContent = formatTime(tap.timeSec);
        tdTime.dataset.timestamp = tap.timeSec;
        tr.appendChild(tdTime);
        const tdValue = document.createElement('td');
        tdValue.className = 'chordCell';
        tdValue.dataset.row = dataIndex;
        tdValue.textContent = tap.value;
        if (activeCell.row === dataIndex && activeCell.col === 2) tdValue.classList.add('active-cell');
        tr.appendChild(tdValue);
        const tdSection = document.createElement('td');
        tdSection.className = 'sectionCell';
        tdSection.dataset.row = dataIndex;
        tdSection.textContent = tap.section || '';
        if (activeCell.row === dataIndex && activeCell.col === 3) tdSection.classList.add('active-cell');
        tr.appendChild(tdSection);
        logTableBody.appendChild(tr);
    };
    if (isPhase2()) {
        taps.forEach((tap, index) => renderRow(tap, index));
    } else {
        for (let i = taps.length - 1; i >= 0; i--) { renderRow(taps[i], i); }
    }
    copyBtn.disabled = selectedRows.size === 0;
    pasteBtn.disabled = selectedRows.size === 0 || clipboard.length === 0;
}
function toggleTappingButtons(enabled) { tapChordBtn.disabled = !enabled; tapSectionBtn.disabled = !enabled; }

// --- Event Listenery ---
insertFileBtn.addEventListener('click', () => fileInput.click());
fileInput.addEventListener('change', e => {
    const file = e.target.files[0]; if (!file) return;
    const fileURL = URL.createObjectURL(file);
    videoPlayer.src = fileURL;
    taps = []; playbackStarted = false;
    toggleTappingButtons(true);
    activeCell = { row: null, col: null }; selectedRows.clear();
    renderTable();
});
videoPlayer.addEventListener('play', () => { playbackStarted = true; toggleTappingButtons(true); renderTable(); });
videoPlayer.addEventListener('pause', () => { toggleTappingButtons(false); renderTable(); });
videoPlayer.addEventListener('ended', () => { toggleTappingButtons(false); renderTable(); });
tapChordBtn.addEventListener('click', () => addTap({ isSection: false }));
tapSectionBtn.addEventListener('click', () => addTap({ isSection: true }));
logTableBody.addEventListener('click', (e) => {
    hidePopover();
    const targetRow = e.target.closest('tr');
    const targetCell = e.target.closest('td');
    if (!targetRow || !targetCell || typeof targetRow.dataset.dataIndex === 'undefined') return;
    const dataIndex = parseInt(targetRow.dataset.dataIndex);
    const colIndex = targetCell.cellIndex;
    activeCell = { row: dataIndex, col: colIndex };
    if (e.shiftKey && lastSelectedRow !== null) {
        const start = Math.min(lastSelectedRow, dataIndex);
        const end = Math.max(lastSelectedRow, dataIndex);
        selectedRows.clear();
        for (let i = start; i <= end; i++) { selectedRows.add(i); }
    } else {
        selectedRows.clear();
        selectedRows.add(dataIndex);
    }
    lastSelectedRow = dataIndex;
    if (colIndex === 1 && taps[dataIndex]) { videoPlayer.currentTime = parseFloat(taps[dataIndex].timeSec); }
    if (!e.shiftKey) {
        if (colIndex === 2) { showPopover(targetCell); }
        if (colIndex === 3) { originalCellValue = targetCell.textContent; targetCell.contentEditable = true; targetCell.focus(); }
    }
    renderTable();
});
logTableBody.addEventListener('blur', (e) => { const cell = e.target; if (cell.isContentEditable) { const rowIndex = parseInt(cell.dataset.row); if (taps[rowIndex]) { if (cell.classList.contains('chordCell')) taps[rowIndex].value = cell.textContent; if (cell.classList.contains('sectionCell')) taps[rowIndex].section = cell.textContent; } cell.contentEditable = false; } }, true);
logTableBody.addEventListener('keydown', (e) => {
    if (!e.target.isContentEditable) return;
    if (e.key === 'Enter') { e.preventDefault(); e.target.blur(); }
    if (e.key === 'Escape') { e.preventDefault(); e.target.textContent = originalCellValue; e.target.blur(); }
});
chordPopover.addEventListener('click', (e) => {
    if (e.target.tagName !== 'BUTTON' || editingRowIndex === null) return;
    const chosenValue = e.target.dataset.value;
    const targetCell = logTableBody.querySelector(`.chordCell[data-row='${editingRowIndex}']`);
    if (chosenValue === 'X') {
        if (targetCell) { originalCellValue = targetCell.textContent; targetCell.contentEditable = true; targetCell.focus(); }
    } else {
        if (taps[editingRowIndex]) taps[editingRowIndex].value = chosenValue;
        renderTable();
    }
    hidePopover();
});
copyBtn.addEventListener('click', copySelection);
pasteBtn.addEventListener('click', pasteSelection);

// ZMENA: Hlavný listener pre klávesnicu teraz rozoznáva Fázu 1 a Fázu 2
window.addEventListener('keydown', (e) => {
    // Globálne skratky, ktoré fungujú vždy
    if (e.key === 'Escape') { if (!chordPopover.classList.contains('hidden')) { hidePopover(); } return; }
    if ((e.ctrlKey || e.metaKey) && e.code === 'KeyC') { e.preventDefault(); copySelection(); return; }
    if ((e.ctrlKey || e.metaKey) && e.code === 'KeyV') { e.preventDefault(); pasteSelection(); return; }
    
    // Ak píšeme do inputu, nerobíme nič
    if (e.target.tagName === 'INPUT' || e.target.isContentEditable) return;

    if (!isPhase2()) {
        // FÁZA 1: TAPOVANIE (video beží)
        if (e.code === 'Space') {
            e.preventDefault(); // Zabráni prehrávaniu/pauze videa
            addTap({ isSection: false });
        }
        if (e.code === 'Enter') {
            e.preventDefault(); // Zabráni iným defaultným akciám
            addTap({ isSection: true });
        }
    } else {
        // FÁZA 2: ANOTÁCIA (video stojí)
        if (activeCell.row === null || taps.length === 0) return;
        if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Enter'].includes(e.key)) e.preventDefault();
        
        let { row, col } = activeCell; const isShift = e.shiftKey;
        if (isShift && selectionAnchor === null) selectionAnchor = row;
        if (!isShift) selectionAnchor = null;
        
        switch (e.key) {
            case 'ArrowUp': row = isPhase2() ? Math.max(row - 1, 0) : Math.min(row + 1, taps.length - 1); break;
            case 'ArrowDown': row = isPhase2() ? Math.min(row + 1, taps.length - 1) : Math.max(row - 1, 0); break;
            case 'ArrowLeft': col = Math.max(col - 1, 2); break;
            case 'ArrowRight': col = Math.min(col + 1, 3); break;
            case 'Enter': {
                const visualRow = [...logTableBody.querySelectorAll('tr')].find(tr => parseInt(tr.dataset.dataIndex) === row);
                const cellNode = visualRow ? visualRow.children[col] : null;
                if(cellNode) {
                    if (col === 2) showPopover(cellNode);
                    if (col === 3) { originalCellValue = cellNode.textContent; cellNode.contentEditable = true; cellNode.focus(); }
                }
                return;
            }
            default: return;
        }
        activeCell = { row, col };
        if (isShift) {
            const start = Math.min(selectionAnchor, row); const end = Math.max(selectionAnchor, row);
            selectedRows.clear();
            for (let i = start; i <= end; i++) selectedRows.add(i);
        } else {
            selectedRows.clear();
            selectedRows.add(row);
            lastSelectedRow = row;
        }
        renderTable();
        const activeCellNode = logTableBody.querySelector('.active-cell');
        if (activeCellNode) activeCellNode.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }
});

exportBtn.addEventListener('click', () => {
    let csv = 'Time,Value,Section\n';
    const sortedTaps = [...taps].sort((a, b) => a.timeSec - b.timeSec);
    sortedTaps.forEach(tap => {
        const value = tap.value.replace(/,/g, ';');
        const section = tap.section ? tap.section.replace(/,/g, ';') : '';
        csv += `${formatTime(tap.timeSec)},${value},${section}\n`;
    });
    const blob = new Blob([csv], { type: 'text/csv' }); const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = 'taps.csv';
    document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
});
const formatKeyNameFull = (key) => `${key.display} ${key.quality === 'm' ? 'mol' : 'dur'}`;
const formatKeyNameShort = (key) => `${key.display}${key.quality === 'm' ? 'm' : ''}`;
function updateModalUI() { selectedKeyDisplay.textContent = formatKeyNameFull(tempKey); qualitySelector.querySelectorAll('button').forEach(btn => btn.classList.toggle('active', btn.dataset.quality === tempKey.quality)); noteGrid.querySelectorAll('button').forEach(btn => btn.classList.toggle('active', btn.dataset.note === tempKey.note)); };
function openModal() { tempKey = { ...currentKey }; updateModalUI(); keyModal.style.display = 'flex'; };
function closeModal() { keyModal.style.display = 'none'; };
selectKeyBtn.addEventListener('click', openModal);
cancelKeyBtn.addEventListener('click', closeModal);
keyModal.addEventListener('click', (e) => { if (e.target === keyModal) closeModal(); });
qualitySelector.addEventListener('click', (e) => { if (e.target.tagName === 'BUTTON') { tempKey.quality = e.target.dataset.quality; updateModalUI(); } });
noteGrid.addEventListener('click', (e) => { if (e.target.tagName === 'BUTTON') { tempKey.note = e.target.dataset.note; tempKey.display = e.target.dataset.display; updateModalUI(); } });
confirmKeyBtn.addEventListener('click', () => {
    currentKey = { ...tempKey };
    selectKeyBtn.textContent = `Key: ${formatKeyNameShort(currentKey)}`;
    closeModal();
});
const initialize = () => { toggleTappingButtons(false); if (!timerInterval) timerInterval = setInterval(updateTimer, 50); };
initialize();
</script>
</body>
</html>
