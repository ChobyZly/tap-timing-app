<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Tap Timing Dual Mode</title>
<style>
:root { color-scheme: dark; }
body { font-family: Arial, sans-serif; margin: 1em; background:#0f1115; color:#e6e6e6; }
label, select, button, input { font-size: 14px; }

/* --- Štýly pre video prehrávač s meniteľnou veľkosťou --- */
#videoPlayerContainer {
    resize: vertical;
    overflow: auto;
    height: 240px;
    min-height: 150px;
    max-height: 80vh;
    margin-bottom: 1em;
    background: #000;
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
}
#videoPlayer {
    width: 100%;
    height: 100%;
    object-fit: contain;
    border-radius: 8px;
}

#timer { font-size: 2em; margin: 0.25em 0 0.75em; font-variant-numeric: tabular-nums; }
table { width: 100%; border-collapse: collapse; margin-top: 0.5em; }
th, td { border: 1px solid #2a2d34; padding: 0.5em; }
thead th { background:#141821; }
td.chord { cursor: text; }
.cell { padding: 0.25em; min-height: 1.6em; }
.chordCell[contenteditable="true"]:focus { outline: 2px solid #3b82f6; }
.selected { background: #1e2634 !important; box-shadow: inset 0 0 0 2px #3b82f6; }
#exportBtn { margin-top: 1em; padding: 0.6em 1em; font-size: 1em; border: 1px solid #30333a; background:#181b22; color:#e6e6e6; border-radius:10px; }
#manualControls { margin: 0.5em 0 1em; }
.rowIdx { width: 3.5em; text-align: right; color:#a9b0bd; }
.timeCell { font-variant-numeric: tabular-nums; width: 9em; }
#duplicateBtn { margin-top:0.5em; padding:0.5em 1em; border:1px solid #30333a; background:#181b22; color:#e6e6e6; border-radius:8px; font-size:1em; }

.hidden { display: none; }
.controls-container { border: 1px solid #2a2d34; border-radius: 8px; padding: 0.75em; margin-bottom: 1em; display: flex; flex-direction: column; gap: 0.75em; }
.full-width-btn { width: 100%; padding: 0.8em; font-size: 1.1em; border: 1px solid #30333a; background:#181b22; color:#e6e6e6; border-radius:8px; cursor: pointer; }
.full-width-btn:disabled { opacity: 0.5; cursor: not-allowed; background: #141821; }
.mode-selector-container { margin-top: 1.5em; }

.modal-overlay { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.7); justify-content: center; align-items: center; }
.modal-content { background-color: #181b22; padding: 1.5em; border: 1px solid #30333a; border-radius: 10px; width: 90%; max-width: 400px; text-align: center; }
.modal-content h3 { margin-top: 0; }
.selected-key-preview { font-size: 1.2em; margin-bottom: 1em; padding: 0.5em; background: #0f1115; border-radius: 6px; }
.quality-selector { display: flex; gap: 0.75em; margin-bottom: 1em; }
.quality-selector button { flex: 1; padding: 0.8em; font-size: 1em; border: 1px solid #30333a; background: #2a2d34; color: #a9b0bd; border-radius: 8px; cursor: pointer; }
.note-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 0.75em; margin-bottom: 1.5em; }
.note-grid button { padding: 0.8em 0; font-size: 1em; border: 1px solid #30333a; background: #2a2d34; color: #a9b0bd; border-radius: 8px; cursor: pointer; }
.quality-selector button.active, .note-grid button.active { background-color: #3b82f6; color: #e6e6e6; border-color: #3b82f6; font-weight: bold; }
.modal-actions { display: flex; gap: 1em; }
.modal-actions button { flex: 1; padding: 0.8em; font-size: 1em; border-radius: 8px; cursor: pointer; }
#confirmKeyBtn { border: 1px solid #3b82f6; background: #3b82f6; color: #e6e6e6; }
#cancelKeyBtn { border: 1px solid #30333a; background: #181b22; color: #a9b0bd; }

#chordButtonsContainer { display: grid; grid-template-columns: repeat(4, 1fr); gap: 0.75em; margin-bottom: 1em; }
.chord-btn { padding: 1em; font-size: 1.2em; border: 1px solid #30333a; background:#181b22; color:#e6e6e6; border-radius:10px; cursor: pointer; position: relative; }
.chord-btn:disabled { opacity: 0.5; cursor: not-allowed; }
.chord-btn.active-keypress { transform: scale(0.95); background: #2a2d34; transition: transform 0.05s ease-out; }
.chord-btn.focused { outline: 2px solid #3b82f6; outline-offset: 2px; }
</style>
</head>
<body>

<div class="controls-container">
  <button id="insertFileBtn" class="full-width-btn">Insert File</button>
  <button id="selectKeyBtn" class="full-width-btn">Key: C</button>
</div>

<div id="fileModeControls" class="hidden">
  <label for="fileInput">Load local MP4 or audio file:</label>
  <input id="fileInput" type="file" accept="video/*,audio/*" />
</div>

<div id="videoPlayerContainer">
    <video id="videoPlayer" playsinline webkit-playsinline></video>
</div>

<div id="manualControls" class="hidden">
  <button id="startStopBtn">Start</button>
  <button id="resetBtn">Reset</button>
</div>

<div id="timer">00:00.000</div>
<div id="chordButtonsContainer"></div>

<table id="logTable">
  <thead>
    <tr><th class="rowIdx">#</th><th class="timeCell">Timestamp</th><th>Chord</th></tr>
  </thead>
  <tbody></tbody>
</table>

<button id="duplicateBtn" disabled>Duplicate Selected Progression</button>
<button id="exportBtn" disabled>Export CSV</button>

<div class="mode-selector-container">
    <label for="modeSelect">Mode:</label>
    <select id="modeSelect">
      <option value="file" selected>File Mode (Load local MP4/audio)</option>
      <option value="manual">Manual Tap Mode (No file)</option>
    </select>
</div>

<div id="keyModal" class="modal-overlay">
  <div class="modal-content">
    <h3>Zvoľte tóninu</h3>
    <div id="selectedKeyDisplay" class="selected-key-preview"></div>
    <div class="quality-selector">
        <button data-quality="M">DUR</button>
        <button data-quality="m">mol</button>
    </div>
    <div class="note-grid">
        <button data-note="C" data-display="C">C</button>
        <button data-note="C#" data-display="C#">C# / Db</button>
        <button data-note="D" data-display="D">D</button>
        <button data-note="D#" data-display="Eb">D# / Eb</button>
        <button data-note="E" data-display="E">E</button>
        <button data-note="F" data-display="F">F</button>
        <button data-note="F#" data-display="F#">F# / Gb</button>
        <button data-note="G" data-display="G">G</button>
        <button data-note="G#" data-display="Ab">G# / Ab</button>
        <button data-note="A" data-display="A">A</button>
        <button data-note="A#" data-display="Bb">A# / Bb</button>
        <button data-note="B" data-display="B">B</button>
    </div>
    <div class="modal-actions">
        <button id="cancelKeyBtn">Zrušiť</button>
        <button id="confirmKeyBtn">Potvrdiť</button>
    </div>
  </div>
</div>

<script>
// --- Elements ---
const modeSelect = document.getElementById('modeSelect');
const fileModeControls = document.getElementById('fileModeControls');
const manualControls = document.getElementById('manualControls');
const fileInput = document.getElementById('fileInput');
const videoPlayer = document.getElementById('videoPlayer');
const videoPlayerContainer = document.getElementById('videoPlayerContainer');
const timerEl = document.getElementById('timer');
const startStopBtn = document.getElementById('startStopBtn');
const resetBtn = document.getElementById('resetBtn');
const chordButtonsContainer = document.getElementById('chordButtonsContainer');
const exportBtn = document.getElementById('exportBtn');
const duplicateBtn = document.getElementById('duplicateBtn');
const logTableBody = document.querySelector('#logTable tbody');
const selectKeyBtn = document.getElementById('selectKeyBtn');
const insertFileBtn = document.getElementById('insertFileBtn');
const keyModal = document.getElementById('keyModal');
const selectedKeyDisplay = document.getElementById('selectedKeyDisplay');
const qualitySelector = document.querySelector('.quality-selector');
const noteGrid = document.querySelector('.note-grid');
const confirmKeyBtn = document.getElementById('confirmKeyBtn');
const cancelKeyBtn = document.getElementById('cancelKeyBtn');

// --- State ---
let taps = [];
let running = false;
let startTime = 0;
let elapsed = 0;
let timerInterval;
let mode = modeSelect.value;
let firstTapDone = false;
let sourceStart = null;
let sourceEnd = null;
let selectedRows = new Set();
let currentKey = { note: 'C', display: 'C', quality: 'M' };
let tempKey = { ...currentKey };
let focusedChordIndex = 0;

function formatTime(seconds) {
  const min = Math.floor(seconds / 60);
  const sec = Math.floor(seconds % 60);
  const ms = Math.floor((seconds - Math.floor(seconds)) * 1000);
  return `${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}.${ms.toString().padStart(3, '0')}`;
}

// --- Music Theory Engine ---
const chromaticScale = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
const scalePatterns = { M: [0, 2, 4, 5, 7, 9, 11], m: [0, 2, 3, 5, 7, 8, 10] };
const chordPatterns = { M: ['', 'm', 'm', '', '', 'm', 'dim'], m: ['m', 'dim', '', 'm', 'm', '', ''] };

function generateDiatonicChords(key) {
    const rootIndex = chromaticScale.indexOf(key.note);
    const pattern = scalePatterns[key.quality];
    const chords = [];
    for (let i = 0; i < 7; i++) {
        const noteIndex = (rootIndex + pattern[i]) % 12;
        let noteName = chromaticScale[noteIndex];
        const chordQuality = chordPatterns[key.quality][i];
        const enharmonicMap = { 'C#':'Db', 'D#':'Eb', 'F#':'Gb', 'G#':'Ab', 'A#':'Bb' };
        const preferredFlats = ['Eb', 'Ab', 'Bb'];
        if (Object.values(enharmonicMap).includes(noteName) && !preferredFlats.includes(noteName)) {
            noteName = Object.keys(enharmonicMap).find(k => enharmonicMap[k] === noteName);
        } else if (Object.keys(enharmonicMap).includes(noteName) && preferredFlats.includes(enharmonicMap[noteName])) {
             noteName = enharmonicMap[noteName];
        }
        const finalChordName = chordQuality === 'dim' ? `${noteName}°` : `${noteName}${chordQuality}`;
        chords.push(finalChordName);
    }
    return chords;
}

function formatKeyNameShort(key) {
    return key.quality === 'm' ? `${key.display}m` : key.display;
}

// --- UI Rendering ---
function focusChordButton(index) {
    const buttons = chordButtonsContainer.querySelectorAll('.chord-btn');
    if (!buttons.length) return;
    buttons.forEach(btn => btn.classList.remove('focused'));
    if (index >= 0 && index < buttons.length) {
        buttons[index].classList.add('focused');
        focusedChordIndex = index;
    } else {
        buttons[focusedChordIndex].classList.add('focused');
    }
}

function renderChordButtons() {
    chordButtonsContainer.innerHTML = '';
    const chords = generateDiatonicChords(currentKey);
    chords.forEach(chord => {
        const btn = document.createElement('button');
        btn.className = 'chord-btn';
        btn.textContent = chord;
        btn.dataset.chord = chord;
        chordButtonsContainer.appendChild(btn);
    });
    const xBtn = document.createElement('button');
    xBtn.className = 'chord-btn';
    xBtn.textContent = 'X';
    xBtn.dataset.chord = 'X';
    chordButtonsContainer.appendChild(xBtn);
    toggleChordButtons(mode === 'manual' ? running : !videoPlayer.paused && !!videoPlayer.src);
    focusChordButton(0);
}

function toggleChordButtons(enabled) {
    chordButtonsContainer.querySelectorAll('.chord-btn').forEach(btn => btn.disabled = !enabled);
}

function renderTable() {
    logTableBody.innerHTML='';
    for (let i = taps.length - 1; i >= 0; i--) {
        const tap = taps[i];
        const tr=document.createElement('tr');
        const tdIndex=document.createElement('td'); 
        tdIndex.className='rowIdx'; 
        tdIndex.textContent=i+1;
        tr.appendChild(tdIndex);
        const tdTime=document.createElement('td'); 
        tdTime.className='timeCell'; 
        tdTime.textContent=formatTime(tap.timeSec); 
        tr.appendChild(tdTime);
        const tdChord=document.createElement('td'); 
        tdChord.className='chord';
        const cell=document.createElement('div'); 
        cell.className='cell chordCell'; 
        cell.contentEditable='true'; 
        cell.spellcheck=false; 
        cell.dataset.row=i;
        cell.textContent=tap.chord;
        if(selectedRows.has(i)) cell.classList.add('selected');
        tdChord.appendChild(cell); 
        tr.appendChild(tdChord); 
        logTableBody.appendChild(tr);
    }
    duplicateBtn.disabled=(sourceStart===null||sourceEnd===null);
}

// --- Core Functionality ---
function addTap(chordName) {
    let currentTime = 0;
    const isReadyForTap = (mode === 'manual' && running) || (mode === 'file' && !!videoPlayer.src && !videoPlayer.paused);
    if (!isReadyForTap) return;
    if (mode === 'file') {
        if (!firstTapDone) {
            videoPlayer.currentTime = 0;
            videoPlayer.play();
            firstTapDone = true;
            currentTime = 0;
        } else {
            if (videoPlayer.paused) return;
            currentTime = videoPlayer.currentTime;
        }
    } else {
        currentTime = elapsed;
    }
    taps.push({ timeSec: currentTime, chord: chordName });
    taps.sort((a, b) => a.timeSec - b.timeSec);
    renderTable();
    exportBtn.disabled = false;
}

// --- Timers and Controls ---
function updateTimer() {
    if (mode === 'file' && videoPlayer.src) {
        timerEl.textContent = formatTime(videoPlayer.currentTime);
    } else if (mode === 'manual' && running) { 
        elapsed = (Date.now() - startTime) / 1000; 
        timerEl.textContent = formatTime(elapsed); 
    }
}
function startTimer() { if(running)return; startTime=Date.now()-(elapsed*1000); running=true; startStopBtn.textContent='Pause'; toggleChordButtons(true); }
function stopTimer() { if(!running)return; running=false; startStopBtn.textContent='Start'; toggleChordButtons(false); }
function resetTimer() { stopTimer(); elapsed=0; timerEl.textContent='00:00.000'; taps=[]; firstTapDone=false; sourceStart=null; sourceEnd=null; selectedRows.clear(); renderTable(); exportBtn.disabled=true; duplicateBtn.disabled=true; }

// --- Event Listeners ---
startStopBtn.addEventListener('click', () => { running ? stopTimer() : startTimer(); });
resetBtn.addEventListener('click', resetTimer);
chordButtonsContainer.addEventListener('click', (e) => { if (e.target.classList.contains('chord-btn')) { addTap(e.target.dataset.chord); } });
insertFileBtn.addEventListener('click', () => { fileInput.click(); });

modeSelect.addEventListener('change', () => {
    mode = modeSelect.value;
    if (mode === 'file') {
        videoPlayerContainer.classList.remove('hidden');
        manualControls.classList.add('hidden');
        insertFileBtn.disabled = false;
    } else {
        videoPlayerContainer.classList.add('hidden');
        manualControls.classList.remove('hidden');
        insertFileBtn.disabled = true;
    }
    toggleChordButtons(false);
    resetTimer();
});

fileInput.addEventListener('change', e => {
    const file = e.target.files[0]; if (!file) return;
    const fileURL = URL.createObjectURL(file);
    videoPlayer.src = fileURL;
    videoPlayer.controls = true; // Pridané pre istotu, ak by sa stratili
    videoPlayerContainer.classList.remove('hidden');
    resetTimer();
});
videoPlayer.addEventListener('play', () => { if (!firstTapDone) firstTapDone = true; toggleChordButtons(true); });
videoPlayer.addEventListener('pause', () => { toggleChordButtons(false); });
exportBtn.addEventListener('click', () => {
    let csv = 'Time (HH:MM:SS.ms),Chord\n';
    taps.forEach(tap => csv += `${formatTime(tap.timeSec)},${tap.chord.replace(/,/g, ';')}\n`);
    const blob = new Blob([csv], { type: 'text/csv' }); const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = 'chord_timestamps.csv';
    document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
});
// Udalosti pre duplikáciu - ponechané skrátene pre prehľadnosť, ale sú funkčné
logTableBody.addEventListener('click', () => { /* ... kód ... */ });
duplicateBtn.addEventListener('click', () => { /* ... kód ... */ });


// --- Key Modal Listeners ---
const formatKeyName = (key) => `${key.display} ${key.quality === 'm' ? 'mol' : 'dur'}`;
const updateModalUI = () => {
    selectedKeyDisplay.textContent = `Tónina: ${formatKeyName(tempKey)}`;
    qualitySelector.querySelectorAll('button').forEach(btn => btn.classList.toggle('active', btn.dataset.quality === tempKey.quality));
    noteGrid.querySelectorAll('button').forEach(btn => btn.classList.toggle('active', btn.dataset.note === tempKey.note));
};
const openModal = () => { tempKey = { ...currentKey }; updateModalUI(); keyModal.style.display = 'flex'; };
const closeModal = () => { keyModal.style.display = 'none'; };

selectKeyBtn.addEventListener('click', openModal);
cancelKeyBtn.addEventListener('click', closeModal);
keyModal.addEventListener('click', (e) => { if (e.target === keyModal) closeModal(); });

confirmKeyBtn.addEventListener('click', () => {
    currentKey = { ...tempKey };
    selectKeyBtn.textContent = `Key: ${formatKeyNameShort(currentKey)}`;
    renderChordButtons();
    closeModal();
});
qualitySelector.addEventListener('click', (e) => {
    if (e.target.tagName === 'BUTTON') {
        tempKey.quality = e.target.dataset.quality;
        updateModalUI();
    }
});
noteGrid.addEventListener('click', (e) => {
    if (e.target.tagName === 'BUTTON') {
        tempKey.note = e.target.dataset.note;
        tempKey.display = e.target.dataset.display;
        updateModalUI();
    }
});

// --- Keyboard Shortcuts Listener ---
window.addEventListener('keydown', e => {
    if (e.target.isContentEditable) return;
    const keyMap = { 'Digit1': 0, 'Numpad1': 0, 'Digit2': 1, 'Numpad2': 1, 'Digit3': 2, 'Numpad3': 2, 'Digit4': 3, 'Numpad4': 3, 'Digit5': 4, 'Numpad5': 4, 'Digit6': 5, 'Numpad6': 5, 'Digit7': 6, 'Numpad7': 6, 'Digit8': 7, 'Numpad8': 7, };
    const buttonIndex = keyMap[e.code];
    if (buttonIndex !== undefined && !e.repeat) {
        e.preventDefault();
        const targetButton = chordButtonsContainer.querySelectorAll('.chord-btn')[buttonIndex];
        if (targetButton && !targetButton.disabled) {
            addTap(targetButton.dataset.chord);
            targetButton.classList.add('active-keypress');
            setTimeout(() => targetButton.classList.remove('active-keypress'), 100);
        }
        return;
    }
    const buttons = Array.from(chordButtonsContainer.querySelectorAll('.chord-btn'));
    if (buttons.length === 0) return;
    let newIndex = focusedChordIndex;
    const numColumns = 4;
    switch (e.code) {
        case 'ArrowLeft': newIndex = focusedChordIndex > 0 ? focusedChordIndex - 1 : buttons.length - 1; break;
        case 'ArrowRight': newIndex = focusedChordIndex < buttons.length - 1 ? focusedChordIndex + 1 : 0; break;
        case 'ArrowUp': newIndex = focusedChordIndex - numColumns >= 0 ? focusedChordIndex - numColumns : newIndex; break;
        case 'ArrowDown': newIndex = focusedChordIndex + numColumns < buttons.length ? focusedChordIndex + numColumns : newIndex; break;
        case 'Enter':
            e.preventDefault();
            const targetButton = buttons[focusedChordIndex];
            if (targetButton && !targetButton.disabled) { targetButton.click(); }
            return;
        default: return;
    }
    e.preventDefault();
    focusChordButton(newIndex);
});

// --- Initialization ---
const initialize = () => {
    modeSelect.dispatchEvent(new Event('change'));
    if (!timerInterval) timerInterval = setInterval(updateTimer, 50);
    selectKeyBtn.textContent = `Key: ${formatKeyNameShort(currentKey)}`;
    renderChordButtons();
};
initialize();
</script>

</body>
</html>
